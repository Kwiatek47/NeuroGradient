<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 100%);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            height: 100vh;
        }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Segoe UI', sans-serif;
            color: #444;
            background: rgba(255,255,255,0.7);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 280px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>Growing Mind Tree</h2>
        <p><strong>Tryb Focus (Slow)</strong></p>
        <p>Input 0.5 = 5 minut do pełnego wzrostu.</p>
        <hr>
        <p>Input P: <span id="val-p">0.00</span></p>
        <p>Stan Drzewa: <span id="val-maturity">0.0</span>%</p>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // --- STATE VARIABLES ---

        let inputP = 0;
        let treeMaturity = 0;

        // Zmienne wizualne
        let focusLevel = 0;
        let currentTreeSize = 0;
        let currentBloomLevel = 0;

        let time = 0;
        let fallingLeaves = [];
        let branchBloomState = new Map();

        // --- KONFIGURACJA PRĘDKOŚCI ---

        // Obliczenie: 5 minut (300s) przy input 0.5
        // 300s * 60fps = 18000 klatek.
        // 1.0 (pełne drzewo) / (18000 * 0.5) = ~0.000111
        const GROWTH_SPEED = 0.000111;

        const MAX_TREE_SIZE = 180;
        const MIN_TREE_SIZE = 80;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- ORGANIC TREE DRAWING ---
        function drawTree(x, y, len, angle, width, key) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);

            ctx.beginPath();
            ctx.moveTo(0, 0);

            let curveX = width * 0.3;
            ctx.quadraticCurveTo(curveX, -len/2, 0, -len);

            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.translate(0, -len);

            if (len < 15) {
                if (treeMaturity > 0.2) {
                    drawNaturalLeaf();

                    // LOGIKA KWIATÓW (STATYCZNE)
                    let hasBloom = branchBloomState.has(key);

                    if (hasBloom) {
                        drawFlower(currentBloomLevel);

                        // Usychanie
                        if (currentBloomLevel < 0.1) {
                            branchBloomState.delete(key);
                        }

                    } else if (currentBloomLevel > 0.6 && Math.random() < currentBloomLevel * 0.005) {
                        // Powstawanie
                        drawFlower(currentBloomLevel);
                        branchBloomState.set(key, true);
                    }
                }
                ctx.restore();
                return;
            }

            // CALCULATE ANGLES & WIND
            let wind = Math.sin(time + len * 0.05) * (2 + (1 - treeMaturity) * 3);
            let spread = 25 + (treeMaturity * 15);

            drawTree(0, 0, len * 0.8, spread + wind, width * 0.7, key + 'R');
            drawTree(0, 0, len * 0.65, -spread - 10 + wind, width * 0.7, key + 'L');

            if (len > 40) {
                drawTree(0, 0, len * 0.5, wind, width * 0.6, key + 'C');
            }

            ctx.restore();
        }

        function drawNaturalLeaf() {
            let size = (treeMaturity * 8) + 2;

            let r = 180 + (treeMaturity * -150);
            let g = 255 + (treeMaturity * -75);
            let b = 110 + (treeMaturity * -90);

            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;

            ctx.beginPath();
            ctx.ellipse(0, 0, size, size/2, Math.PI/4, 0, Math.PI*2);
            ctx.fill();
        }

        function drawFlower(bloomFactor) {
            const petalCount = 5;
            const petalLength = 2 + (bloomFactor * 10);

            const petalColor = 'rgba(255, 192, 203, 0.9)';
            const centerColor = '#FFD700';

            ctx.save();

            ctx.fillStyle = petalColor;
            for (let i = 0; i < petalCount; i++) {
                ctx.rotate((2 * Math.PI) / petalCount);
                ctx.beginPath();
                ctx.ellipse(petalLength / 3, 0, petalLength * 0.5, petalLength * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = centerColor;
            ctx.beginPath();
            ctx.arc(0, 0, petalLength * 0.15, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // --- FALLING LEAVES ---
        function spawnLeaf() {
            fallingLeaves.push({
                x: width/2 + (Math.random() - 0.5) * 500,
                y: height - (currentTreeSize * 0.8) - Math.random() * 100,
                size: Math.random() * 6 + 4,
                speedY: Math.random() * 1.5 + 0.5,
                swayFreq: Math.random() * 0.1,
                swayAmp: Math.random() * 2,
                angle: Math.random() * 360,
                color: Math.random() > 0.5 ? '#FFD700' : '#FFA07A'
            });
        }

        function updateLeaves() {
            for (let i = fallingLeaves.length - 1; i >= 0; i--) {
                let l = fallingLeaves[i];
                l.y += l.speedY;
                l.x += Math.sin(time + l.y * l.swayFreq) * l.swayAmp;
                l.angle += 0.05;

                ctx.save();
                ctx.translate(l.x, l.y);
                ctx.rotate(l.angle);

                ctx.fillStyle = l.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, l.size, l.size/2, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();

                if (l.y > height) fallingLeaves.splice(i, 1);
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            ctx.clearRect(0, 0, width, height);
            time += 0.03;

            // --- GŁÓWNA LOGIKA WZROSTU OPARTA NA INPUT P ---

            treeMaturity += inputP * GROWTH_SPEED;

            if (treeMaturity > 1.0) treeMaturity = 1.0;
            if (treeMaturity < 0.0) treeMaturity = 0.0;

            // Mapowanie na wizualia
            focusLevel = treeMaturity;

            let targetSize = MIN_TREE_SIZE + (treeMaturity * (MAX_TREE_SIZE - MIN_TREE_SIZE));
            currentTreeSize += (targetSize - currentTreeSize) * 0.1;

            let targetBloom = 0;
            if (treeMaturity > 0.8) {
                targetBloom = (treeMaturity - 0.8) * 5;
            }
            currentBloomLevel += (targetBloom - currentBloomLevel) * 0.05;


            if (currentTreeSize > 10) {
                drawTree(width / 2, height, currentTreeSize, 0, 22, 'S');
            }

            // Spadanie liści - rzadziej, bo proces jest wolniejszy
            if (inputP < -0.1 && treeMaturity < 0.5) {
                 if (Math.random() > 0.95) spawnLeaf(); // Jeszcze rzadziej
            }

            updateLeaves();

            // Wyświetlaj z większą dokładnością (1 miejsce po przecinku)
            document.getElementById('val-maturity').innerText = (treeMaturity * 100).toFixed(1);

            requestAnimationFrame(animate);
        }

        // --- INPUT SIMULATION ---
        window.addEventListener('mousemove', (e) => {
            let centerX = width / 2;
            let mouseX = e.clientX;
            let dist = mouseX - centerX;
            let p = dist / centerX;

            if (p > 1) p = 1;
            if (p < -1) p = -1;
            if (Math.abs(p) < 0.05) p = 0;

            inputP = p;

            document.getElementById('val-p').innerText = inputP.toFixed(2);
            let ui = document.getElementById('ui');
            if(p > 0) ui.style.borderLeft = "5px solid green";
            else if (p < 0) ui.style.borderLeft = "5px solid brown";
            else ui.style.borderLeft = "5px solid gray";
        });

        animate();
    </script>
</body>
</html>